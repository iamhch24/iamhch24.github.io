---
title: "[Study] 자바 웹을 다루는 기술"
categories:
    - dev
tags:
    - dev
    - java 
    - jsp 
    - spring
toc: true

---
# 3장 설치
오라클 11g release 2를 설치 완료후
cmd 창에서

```
C:\Users\iamhch>sqlplus

SQL*Plus: Release 11.2.0.2.0 Production on 금 1월 1 19:16:26 2021

Copyright (c) 1982, 2014, Oracle.  All rights reserved.

Enter user-name: system
Enter password:

Connected to:
Oracle Database 11g Express Edition Release 11.2.0.2.0 - 64bit Production

SQL> create user scott identified by tiger;

User created.

SQL> grant resource, connect to scott;

Grant succeeded.

SQL> exit
Disconnected from Oracle Database 11g Express Edition Release 11.2.0.2.0 - 64bit Production

C:\Users\iamhch>sqlplus

SQL*Plus: Release 11.2.0.2.0 Production on 금 1월 1 19:21:10 2021

Copyright (c) 1982, 2014, Oracle.  All rights reserved.

Enter user-name: scott
Enter password:

Connected to:
Oracle Database 11g Express Edition Release 11.2.0.2.0 - 64bit Production

SQL>
```


# 4장 웹 애플리케이션 이해하기
톰캣에서 컨텍스트를 인식하는 방법

폴더 구조가 아래와 같아야 함.
(웹 애플리케이션 이름) >  (WEB-INF) > (classes) + (lib) + web.xml

```
web.xml
<?xml version="1.0" encoding="UTF-8"?>
<web-app  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xmlns="http://java.sun.com/xml/ns/javaee" 
xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd" 
id="WebApp_ID"  version="3.0">
</web-app>
```
main.html은 (웹 애플리케이션 이름) 폴더에 생성함.
필요에 따라 images 등 폴더를 생성해도 됨

웹 브라우저로 요청하는 주소
	http://IP주소:포트번호/컨텍스트이름/요청파일이름

> 컨테이너에 웹 애플리케이션을 등록하는 방법 2가지
1.  %CATALINA_HOME%webApps 디렉토리 하위에 웹 애플리케이션 폴더를 넣음
2.  server.xml에 직접 웹 애플리케이션을 등록함 
                       
```
server.xml
<Context path="/컨텍스트 이름" docBase="실제 웹 애플리케이션의 WEB-INF 디렉토리 위치" reloadable="true or false"/>
(실제예시)
<Context path="/webMal" docBase="C:\\webShop" reloadable="true" />
```
위 예제에서 /webShop이 아닌 /webMal 이라는 이름으로 컨텍스트를 등록했음.

등록되지 않은 컨텍스트를 브라우져에서 호출하면 404 에러를 출력함.

> 배치 Deploy란?
- 개발이 완료된 웹 애플리케이션을 실제 사용자들에게 서비스하기 위한 작업
- 이클립스 상단 메뉴에서 File>Export>Web>WAR file 선택
- WAR 파일을 톰캣가 설치된 webapps 폴더 아래 넣어두고
- 다시 톰캣을 재실행하면 자동으로 webapps 폴더 아래 WAR 파일이 압축 풀리며 컨텍스트 폴더가 생성이 됨

> html/jsp 파일의 인코딩을 자동으로 지정 : windows>preference>web>utf-8


# 5장 서블릿
> 서블릿이란?
* 서버 쪽에서 실행되면서 클라이언트의 요청에 따라 동적으로 서비스를 제공하는 자바 클래스 
* HttpServelt을 상속받음

```
### **1) Servlet**
Servlet은 서블릿 프로그램을 개발할때 반드시 구현해야 하는 메서드를 선언하고 있는 인터페이스이다.  **이 표준을 구현해야 서블릿 컨테이너가 해당 서블릿을 실행할수 있다.**

### **2) GenericServlet**
GenericServlet은 Servlet 인터페이스를 상속하여 클라이언트-서버 환경에서 서버단의 애플리케이션으로서 필요한 기능을 구현한 추상클래스이다. service() 메서드를 제외한 모든 메서드를 재정의하여 적절한 기능으로 구현했다. GenericServlet 클래스를 상속하면 애플리케이션의 프로토콜에 따라 메서드 재정의 구문을 적용해야 한다.

### **3) HttpServlet**
일반적으로 서블릿이라하면 거의 대부분 HttpServlet을 상속받은 서블릿을 의미한다. HttpServlet은 GenericServlet을 상속받았으며, GenericServlet의 유일한 추상 메서드인 service를 HTTP 프로토콜 요청 메서드에 적합하게 재구현해놨다.
이미 DELETE, GET, HEAD, OPTIONS, POST, PUT, TRACE를 처리하는 메소드가 모두 정의되어 있다.
  
출처: [https://12bme.tistory.com/555](https://12bme.tistory.com/555) [길은 가면, 뒤에 있다.]
```

* 클라이언트 요청 >> public service() 호출 >> protected service() 호출 >>  doXXX 호출
* 서블릿 생명 주기 메서드 :: 초기화 init() >> 작업수행 doXXX >> 종료 destory()
* 서블릿 생성 과정 :: 사용자 정의 서블릿 클래스 만들기 >> 서블릿 생명주기 메서드 구현 >> 서블릿 매핑 작업 >> 웹 브라우저에서 서블릿 매핑 이름으로 요청하기

> 서블릿 매핑 방법

```
각 프로젝트에 있는 web.xml에서 설정
<servlet> 태그와 <servlet-mapping> 태그를 이용함
여러 개의 서블릿 매핑 시에는 <servlet> 태그를 먼저 정의하고 <servlet-mapping> 태그를 정의함
애너테이션을 이용하는 방법 :: 서블릿 클래스 위에 @WebServlet("/서블릿매핑이름"); 기록

(예시)
	<servlet>
		<servlet-name>aaa</servlet-name>
		<servlet-class>sec01.ex01.FirstServlet</servlet-class>
	</servlet>
	<servlet-mapping>
		<servlet-name>aaa</servlet-name>
		<url-pattern>/first</url-pattern>
	</servlet-mapping>
```

* 이클립스에서 서블릿 소스 만들 때 build path에 libraries에서 servlet-api.jar를 추가해 줘야 함.
 

# 6장 서블릿 기초 :: 요청과 응답 처리
* 서블릿 요청과 응답 수행 API 기능
요청 API :: javax.sevlet.http.HttpServletRequest 클래스
응답 API :: javax.sevlet.http.HttpServletResponse 클래스

* 브라우저에서 요청은 
* <form> 태그를 이용해 서블릿에 요청

* <form> 태그 여러가지 속성
name : 자바스크립트에서 폼 태그 접근할 때 주로 사용
method : get/post
action : JSP나 서블릿을 지정함
encType : 전송할 데이터의 인코딩 방식

* 서블릿에서 form 태그의 정보를 받는다. = HttpServeltRequest 클래스
String getParameter(String name) :: name값을 알고 있을 때 name에 전송된 값을 받아오는데 사용
String[] getParameterValues(String name) :: 같은 name에 대해 여러 개의 값을 얻을 때 사용
Enumeration getParameterNames() :: name값을 모를 때 사용

* 서블릿의 응답 처리 방법
doGet()이나 doPost() 메서드 안에서 처리함.
javax.servlet.http.HttpServletResponse 객체를 이용함
setContentType()을 이용해 클라이언트에게 전송할 데이터 종류 (MIME-TYPE)을 지정함.
클라이언트(웹 브라우저)와 서블릿의 통신은 자바I/O 스트림을 이용함

> MIME-TYPE 지정예
HTML : text/html
일반텍스트 : text/plain
XML 데이터 전송시 : application/xml

* HpptServletRespnse 를 이용한 서블릿 응답 실습
1 setContentType()을 이용해 MIME-TYPE 지정
2 데이터를 출력할 PrintWriter 객체 생성
3 출력 데이터를 HTML 형식으로 만듦
4 PrintWriter의 print()나 println()을 이용해 데이터 출력

* Integer.parseInt() :: 숫자를 넘겨받아도 문자로 전송되어 들어오기에 int로 형변환해줘야 함.

# 7장 서블릿 비즈니스 로직 처리 

서블릿 기본 기능 3가지
1) 요청
2) 응답
3) 비즈니스 로직 처리 (DB연동 + 타 시스템 연동, API처리)

자바 클래스를 통해 DB와 연동함

MemberServlet
MemberDAO
MemberVO
JDBC

자바 데이터베이스 강좌
https://cafe.naver.com/standardjava
https://cafe.naver.com/spring4shoppingmall

테이블 :: SQL developer 이용
id varchar2(10)
pwd varchar2(10)
name varchar2(50)
email varchar2(50)
joinDate date default sysdate

오라클 드라이버 (ojdbc6.jar --> 프로젝트의 /WebContent/WEB-INF/lib 폴더에 복사하여 붙여넣음)
https://www.oracle.com/technetwork/apps-tech/jdbc-112010-090769.html

```
--회원 테이블 생성
create table t_member(
    id varchar2(10) primary key,
    pwd varchar2(10),
    name varchar2(50),
    email varchar2(50),
    joinDate date default sysdate
);

--회원 정보 추가
insert into t_member
values('hong','1212','홍길동','hong@gmail.com',sysdate);

insert into t_member
values('lee','1212','이순신','lee@test.com',sysdate);

insert into t_member
values('kim','1212','김유신','kim@web.com',sysdate);
commit;

select * from t_member;
```

>MemberDAO.java

```
package sec01.ex01;

import java.sql.Connection;
import java.sql.Date;
import java.sql.DriverManager;
import java.sql.ResultSet;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.List;

public class MemberDAO {
	private static final String driver= "oracle.jdbc.driver.OracleDriver";
	private static final String url= "jdbc:oracle:thin:@localhost:1521:XE";
	private static final String user= "scott";
	private static final String pwd= "tiger";
	private Connection con;
	private Statement stmt;
	
	public List<MemberVO> listMembers(){
		List<MemberVO> list = new ArrayList<MemberVO>();
		
		try {
			connDB();
			String query = "select * from t_member";
			System.out.println(query);
			ResultSet rs = stmt.executeQuery(query);
			
			while(rs.next()) {
				String id = rs.getString("id");
				String pwd = rs.getString("pwd");
				String name = rs.getString("name");
				String email = rs.getString("email");
				Date joinDate = rs.getDate("joinDate");
				
				MemberVO vo = new MemberVO();
				vo.setId(id);
				vo.setPwd(pwd);
				vo.setName(name);
				vo.setEmail(email);
				vo.setJoinDate(joinDate);
				
				list.add(vo);
			}
			rs.close();
			stmt.close();
			con.close();
				
		}catch(Exception e) {
			e.printStackTrace();
		}
		return list;
	}
	
	private void connDB() {
		try {
			Class.forName(driver);
			System.out.println("Oracle 드라이버 로딩 성공");
			con = DriverManager.getConnection(url,user,pwd);
			System.out.println("Connection 생성 성공");
			stmt = con.createStatement();
			System.out.println("Statement 생성 성공");
		}catch(Exception e) {
			e.printStackTrace();
		}
	}
}
```


* PreparedStatement 를 이용 :: SQL을 컴파일하여 사용함으로 속도 향상, ? 사용으로 쿼리문 이용이 편리함

* DB driver 연결시 가장 시간이 많이 걸림 ⇒ ConnectionPool 을 사용함 (백그라운드 운영)
* JNDI (Java Naming and Directory Interface) 사용
* 톰캣 DataSource 설정 :: JDBC드라이버를 /WEB-INF/lib 폴더에 설치
* --> ConnectionPool 기능 관련 jar파일을 /WEB-INF/lib 폴더에 설치
* --> CATALINA_HOME\context.xml에 Connection 객체 생성시 연결할 데이터 베이스 정보를 JNDI로 설정함
* --> DAO 클래스에서 데이터 베이스 연동 시 JNDI 이름으로 데이터베이스를 연결해서 작업함

* ConnectionPool 관련 라이브러리 다운받기 
* http://www.java2s.com/Code/Jar/t/Downloadtomcatdbcp7030jar.htm


>톰캣 서버 context.xml 

```
<Resource
	    name="jdbc/oracle"    			// Datasource에 대한 JNDI 이름
	    auth="Container" 				// 인증주체
	    type="javax.sql.Datasource"		//데이터베이스 종류별 Datasource
	    driverClassName="oracle.jdbc.OracleDriver"	
	    url="jdbc:orcale:thin@localhost:1521:XE"
	    username="scott"
	    password="tiger"
	    maxActive="50"			// 동시에 최대로 DB 연결 connection 수
	    maxWait="-1" />			// 새로운 연결 기다리는 최대시간
```

>MemberDAO.java
```Java
package sec02.ex01;

import java.sql.Connection;
import java.sql.Date;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.util.ArrayList;
import java.util.List;

import javax.naming.Context;
import javax.naming.InitialContext;
import javax.sql.DataSource;

public class MemberDAO {
	/*
	private static final String driver = "oracle.jdbc.driver.OracleDriver";
	private static final String url = "jdbc:oracle:thin:@localhost:1521:XE";
	private static final String user = "scott";
	private static final String pwd = "tiger";
	*/
	
	private Connection con;
	private PreparedStatement pstmt;
	private DataSource dataFactory;
	
	public MemberDAO() {
		try {
			Context ctx = new InitialContext();
			Context envContext = (Context) ctx.lookup("java:/comp/env");
			dataFactory = (DataSource) envContext.lookup("jdbc/oracle");
		} catch (Exception e) {
			e.printStackTrace();
		}
	}

	public List listMembers() {
		List list = new ArrayList();
		try {
			//connDB();
			con=dataFactory.getConnection();
			String query = "select * from t_member ";
			System.out.println("prepareStatememt: " + query);
			pstmt = con.prepareStatement(query);
			ResultSet rs = pstmt.executeQuery();
			while (rs.next()) {
				String id = rs.getString("id");
				String pwd = rs.getString("pwd");
				String name = rs.getString("name");
				String email = rs.getString("email");
				Date joinDate = rs.getDate("joinDate");
				MemberVO vo = new MemberVO();
				vo.setId(id);
				vo.setPwd(pwd);
				vo.setName(name);
				vo.setEmail(email);
				vo.setJoinDate(joinDate);
				list.add(vo);
			}
			rs.close();
			pstmt.close();
			con.close();
		} catch (Exception e) {
			e.printStackTrace();
		}
		return list;
	}

	/*
	private void connDB() {
		try {
			Class.forName(driver);
			System.out.println("Oracle 드라이버 로딩 성공");
			con = DriverManager.getConnection(url, user, pwd);
			System.out.println("Connection 생성 성공");
		} catch (Exception e) {
			e.printStackTrace();
		}
	}
	*/
	
}
```

* 현업에서 사용하는 기술 2가지 = PreparedStatement + DataSource 기능

* PreparedStatement에서 insert문 사용방법
1 insert문에서 회원정보를 저장하기 위해 ?(물음표)를 사용함
2 ?는 id,pwd,name,age에 순서대로 대응함
3 각 ?에 대응하는 값을 지정하기 위해 PreparedStatement의 setter를 이용함
4 setter() 메서드의 첫 번째 인자는 '?'의 순서를 지정함
5 ?은 1부터 시작함
6 insert, delete, update문은 executeUpdate() 메서드를 호출함

# 8장 서블릿 확장 API

>서블릿 포워드 방법 -> 데이터 전송도 가능

1 redirect 방법 
- HttpServletResponse 객체의 sendRedirect() 메서드 이용
- 웹 브라우저에 재요청하는 방식
- 형식 : response.sendRedirect("포워드할 서블릿 or JSP");

2 Refresh 방법
- HeepServlet Response 객체의 addHeader() 메서드를 이용
- 웹 브라우저에 재요청하는 방식
- 형식 : response.addHeader("Refresh,"경과시간(초), url=요청할 서블릿 or JSP");

3 location 방법
- 자바스크립트 location 객체의 href 속성을 이용
- 자바스크립트에서 재요청하는 방식
- 형식 loaction.href = '요청할 서블릿 or JSP'

4 dispatch 방법
- 일반적으로 포워딩 기능을 지칭
- 서블릿이 직접 요청하는 방법
- RequestDispatcher 클래스의 forward() 메서드 이용
- 형식 : RequestDispatcher dis = request.getRequestDispatcher("포워드할 서블릿 or JSP");
- dis.forward(request, response);

>바인딩

포워딩 방법은 데이터 전송이 적은 경우 get으로 전송하지만
전달할 변수가 많을 경우에는 바인딩으로 처리함
request - setAttribute() / getAttribute() / removeAttribute()
리다이렉트 방법으로는 바인딩 보낼 수 없음 (다른 요청이 됨)
--> 디스패치 방식으로만 바인딩을 보낼 수 있음
== 모델 2나 스프링 에서 포워딩 시 사용함

```Java
request.setAttribute("membersList",membersList);
		RequestDispatcher dispatch = request.getRequestDispatcher("viewMembers");
		dispatch.forward(request, response);
```

>ServletContext와 ServletConfig

ServletContext :: 컨테이너에서 Context마다 생성됨
ServletConfig :: Context 안에서 각 Servlet마다 생성됨 == 인터페이스


# 9장 쿠키, 세션

>쿠키 API 특징

* javax.servlet.http.Cookie를 이용
* HttpServletResponse의 addCookie() 메서드를 이용해 클라이언트 브라우저에 쿠키를 전송한 후 저장함
* HttpServletRequest의 getCookie() 메서드를 이용해 쿠키를 서버로 가져옴

>쿠키 Set -- addCookie()

```Java
	protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		// TODO Auto-generated method stub
		request.setCharacterEncoding("utf-8");
		response.setContentType("text/html;charset=utf-8");
		PrintWriter out = response.getWriter();
		
		Date d = new Date();
		Cookie c = new Cookie("cookieTest",URLEncoder.encode("JSP프로그래밍입니다.","utf-8"));		// URLEncoder.encode 을 이용하여 ASCII로 저장함
		c.setMaxAge(24*60*60); 	// 초단위, 24시간을 유효시간으로 설정함
		response.addCookie(c);	// 브라우저로 전송해서 클라이언트에 저장함
		out.println("현재시간 : " + d);
		out.println("<br> 문자열을 Cookie에 저장합니다.");
	}

```

> 쿠키 Get  -- getCookies(), getName(), getValue()

```Java
	protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		request.setCharacterEncoding("utf-8");
		response.setContentType("text/html;charset=utf-8");
		PrintWriter out = response.getWriter();
		
		Cookie[] allValues = request.getCookies();
		for(int i=0;i<allValues.length;i++) {
			if(allValues[i].getName().equals("cookieTest")) {
				out.println("<h2>Cookie 값 가져오기 : "+URLDecoder.decode(allValues[i].getValue(),"utf-8"));
			}
		}
	
	}

```
* 세션 쿠키는 setMaxAge(-1); 로 설정하면 브라우져 메모리에 설정됨.


### 세션을 이용하여 로그인 정보 바인딩

```Java

if(session.isNew()){
	if(
```
<!--stackedit_data:
eyJoaXN0b3J5IjpbMTM5NjAyMDg0MywxMTIyNTA3MDg0LDc1Nz
Q3NzIzNCwtODI0MDE4MTA0LC0xNDg0MzM5NTY0LDExNzM5MTQ4
NTcsLTE2ODIyMjYzMjMsLTE1NzE0NzAzOTgsOTg5Nzg1MDcyLD
k2MjY4NjM2NiwtMTQ2ODI2NjM5MiwtMjEzNTI0NzA5NCwtMjEw
MTM4MjMzNSwxMzk1ODQ2MDQ3LC0xMzc1OTMxNTMwLDE1MDM1OT
MxMzIsLTE5OTgxMzY1NTEsMTU1NDAwMjM1MSwxMzk3NDY3NDAw
LDE0NjE1NjM3NjVdfQ==
-->